
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> dir.work <- '/home/pgrad2/2448355h/My_PhD_Project/Biv_Ext_Mix_Mod'
> dir.out <- "/home/pgrad2/2448355h/My_PhD_Project/01_Output/Biv_Ext_Mix_Mod/Simulation"
> source(file.path(dir.work, "KRSW/RevExp_U_Functions.r"))
> source(file.path(dir.work, "KRSW/CommonFunctions.r"))
> 
> # install_load_packages <- function(packages) {
> #   nodename <- Sys.info()['nodename']
> #   lib_path <- file.path("/home/pgrad2/2448355h/R/library", nodename)
> #   .libPaths(lib_path)
> #   # Create a separate library folder for each node, if it doesn't exist
> #   if (!dir.exists(lib_path)) {
> #     dir.create(lib_path, recursive = TRUE)
> #   }
> #   
> #   for (package in packages) {
> #     # Check if the package is installed in the specific folder
> #     if(!require(package, character.only = TRUE, lib.loc = lib_path)) {
> #       install.packages(package, lib = lib_path, dependencies = TRUE)
> #       library(package, character.only = TRUE, lib.loc = lib_path)
> #     }
> #     
> #     # Load the package
> #     library(package, character.only = TRUE, lib.loc = lib_path)
> #   }
> # }
> 
> load_install_packages <- function(packages) {
+   for(package in packages){
+     # If the package is not installed, install it
+     if(!require(package, character.only = TRUE)) {
+       install.packages(package, dependencies = TRUE,repos='http://cran.us.r-project.org')
+       # Load the package after installation
+       library(package, character.only = TRUE)
+     } else {
+       # If the package is already installed, just load it
+       library(package, character.only = TRUE)
+     }
+   }
+ }
> 
> # List the packages you want to load
> packages <- c("nimble", "mvtnorm", "tmvtnorm","foreach","doSNOW","parallel")  
> 
> 
> load_install_packages(packages)
Loading required package: nimble
nimble version 1.0.1 is loaded.
For more information on NIMBLE and a User Manual,
please visit https://R-nimble.org.

Note for advanced users who have written their own MCMC samplers:
  As of version 0.13.0, NIMBLE's protocol for handling posterior
  predictive nodes has changed in a way that could affect user-defined
  samplers in some situations. Please see Section 15.5.1 of the User Manual.

Attaching package: ‘nimble’

The following object is masked from ‘package:stats’:

    simulate

Loading required package: mvtnorm
Loading required package: tmvtnorm
Loading required package: Matrix
Loading required package: stats4
Loading required package: gmm
Loading required package: sandwich
Loading required package: foreach
Loading required package: doSNOW
Loading required package: iterators
Loading required package: snow
Loading required package: parallel

Attaching package: ‘parallel’

The following objects are masked from ‘package:snow’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, clusterSplit, makeCluster, parApply,
    parCapply, parLapply, parRapply, parSapply, splitIndices,
    stopCluster

> 
> print(detectCores())
[1] 40
> # t3 <- Sys.time()
> # for (i in 1:1) {
> #   print(i)
> #   seed <- i
> #   d <- 2
> #   a <- c(1.5, 2)
> #   beta <- c(0.5, 0)
> #   sig <- c(0.5, 0.4)
> #   gamma <- c(0.2, 0.1)
> #   n <- 2000
> #   mu <- c(3.5, 4.5)
> #   sd1 <- 1.22
> #   sd2 <- 1.10
> #   rho <- 0.72
> #   sigma <- matrix(c(sd1^2, rho*sd1*sd2, rho*sd1*sd2, sd2^2),ncol=2)
> # 
> #   u.x <- c(5.6, 7)
> #   p <- pmvnorm(lower=rep(-Inf,2), upper=u.x, mean=mu, sigma=sigma, keepAttr = F)
> # 
> #   set.seed(seed)
> #   Y.tail<-sim.RevExpU.MGPD(n=n-floor(n*p),d=d, a=a, beta=beta, sig=sig, gamma=gamma, MGPD = T,std=T)
> # 
> #   # GP scale tail data combined with the bulk data
> #   set.seed(seed)
> #   Y.bulk <- rtmvnorm(floor(n*p), mean=mu, sigma=sigma, lower=c(-Inf,-Inf),upper=u.x)
> # 
> #   # The name of the dataset should be Y for further WAIC calculation.
> #   Y <- rbind(Y.bulk, sweep(Y.tail$X,2,u.x,"+"))
> #   # plot(Y)
> # 
> #   source(file.path(dir.work, 'Simulation/BEMM_Functions.R'))
> # 
> #   detectCores()
> #   this_cluster <- makeCluster(4)
> # 
> #   t1 <- Sys.time()
> #   chain_output <- parLapply(cl = this_cluster, X = 1:4,
> #                             fun = run_MCMC_parallel,
> #                              dat = Y, niter = 200, nburnin=0, thin=10)
> #   t2 <- Sys.time()
> #   print(t2-t1)
> # 
> # 
> #   stopCluster(this_cluster)
> # 
> #   para.name <- colnames(chain_output[[1]]$samples)
> #   rhat.seq <- c()
> #   ess.seq <- c()
> #   for (name in para.name){
> #     post.sp <- cbind(chain_output[[1]]$samples[,name],
> #                      chain_output[[2]]$samples[,name],
> #                      chain_output[[3]]$samples[,name])
> #     rhat.seq <- c(rhat.seq, rhat(post.sp))
> #     ess.seq <- c(ess.seq, ess_basic(post.sp))
> #   }
> #   convg.stat <- data.frame(para.name,rhat.seq,ess.seq )
> # 
> # 
> # 
> #   samples.all <- rbind(chain_output[[1]]$samples,
> #                        chain_output[[2]]$samples,
> #                        chain_output[[3]]$samples)
> #   # waic <- calculateWAIC(samples.all, BivExtMixmodel)
> #   filename <- paste('Scenario1.1_seed',i,'.RData',sep='')
> #   # save(Y, chain_output, convg.stat, file=file.path(dir.out, filename))
> # }
> # t4 <- Sys.time()
> # print(t4-t3)
> #36mins for 200 iter on euclid 01, 2.15 mins for 200 iters on RStudio server
> #22mins for 100 iter on euclid 01, 1.45 mins for 100 iters on RStudio server
> 
> 
> NumberOfCluster <- 40
> cl <- makeCluster(NumberOfCluster)
> registerDoSNOW(cl)
> 
> source(file.path(dir.work, 'Simulation/BEMM_Functions.R'))
> 
> t1 <- Sys.time()
> chain_res <-
+ foreach(i = c(21:100)) %:%
+   foreach(j = 1:3, .packages = c('nimble','mvtnorm','tmvtnorm')) %dopar%{
+     seed <- i
+     d <- 2
+     a <- c(0.5, 1.2)
+     beta <- c(0, 0)
+     sig <- c(0.5, 1.2)
+     gamma <- c(0.3, 0.1)
+     n <- 2000
+     mu <- c(3.5, 4.0)
+     sd1 <- 1
+     sd2 <- 1.5
+     rho <- 0.7
+     sigma <- matrix(c(sd1^2, rho*sd1*sd2, rho*sd1*sd2, sd2^2),ncol=2)
+ 
+     u.x <- c(5.5, 6.7)
+     # u.x <- c(4.7,6)
+     p <- pmvnorm(upper=u.x, mean=mu, sigma=sigma, keepAttr = F)
+ 
+     set.seed(seed)
+     Y.tail<-sim.RevExpU.MGPD(n=n-floor(n*p),d=d, a=a, beta=beta, sig=sig, gamma=gamma, MGPD = T,std=T)
+ 
+     # GP scale tail data combined with the bulk data
+     set.seed(seed)
+     Y.bulk <- rtmvnorm(floor(n*p), mean=mu, sigma=sigma, upper=u.x)
+ 
+     # The name of the dataset should be Y for further WAIC calculation.
+     Y <- rbind(Y.bulk, sweep(Y.tail$X,2,u.x,"+"))
+     run_MCMC_parallel(seed=j, dat=Y, niter=30000, nburnin = 20000, thin=10)
+   }
